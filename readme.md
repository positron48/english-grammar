Вся иерархия грамматики: 01-sections.md
Спецификация JSON на главу: 02-chapter-schema.json
Пример JSON на главу: 03-chapter-example.json

------

## 4) Тесты: какие типы вопросов нужны

Чтобы пользователь не учил ответы, а понимал принцип, банк должен быть **вариативным** по:

- лексике (разные слова),
- контексту (вопрос/отрицание/утверждение),
- “ловушкам” (типичные смешения правил),
- форме задания (не только MCQ).

Набор типов:

- **mcq_single** (один правильный) — быстро, удобно
- **mcq_multi** (несколько правильных) — проверяет понимание условий
- **fill_blank** (вставить форму/слово) — ближе к навыку
- **reorder** (собери предложение) — порядок слов
- **error_spotting** (найди ошибку) — для "типичных ошибок"
- **true_false** (правда или ложь) — проверяет понимание правил

На каждый теоретический блок нужно формировать 3-4 вопроса разных типов.
Вопросы в теле главы и в итоговом тестировании не должны пересекаться.

------

## 5) Инструкции для LLM‑генерации контента (разделы → главы → блоки → вопросы)

Ниже — практичный пайплайн, который хорошо масштабируется и даёт стабильный JSON.

### 5.1. Общий принцип генерации

Генерируй в 3–5 проходов, а не “всё сразу”:

**Проход 1 — План**
 Выход: список theory‑блоков (≤9), цели, список concept_id, список типов упражнений.

**Проход 2 — Теория по блокам**
 Выход: каждый theory‑блок отдельно (проще валидировать), с примерами.

**Проход 3 — Вопросы**
 Выход: большой question_bank, привязанный к theory_block_id/concept_id.

**Проход 4 — Inline quizzes**
 Выход: набор мини‑квизов (ссылки на вопросы из банка или отдельные вопросы).

**Проход 5 — Валидация**
 LLM получает JSON и проверяет:

- нет ли двусмысленности,
- совпадает ли правильный ответ с объяснением,
- нет ли повторов/почти повторов,
- покрыты ли все theory‑блоки.

### 5.2. Жёсткий “контракт” к LLM

Всегда задавай LLM такие ограничения:

- “Верни **только JSON**, без текста вокруг”
- “Используй **стабильные id**: snake_case, без пробелов”
- “Theory‑блоков ≤9”
- “Вопросов в банке ≥60”
- “Каждый вопрос содержит explanation”
- “Каждый вопрос имеет theory_block_id”
- “Примеры: минимум 8 на главу, из них минимум 2 — отрицание, 2 — вопрос”

### 5.3. Шаблоны промптов (готовые)

**A) Промпт на план главы**

- Роль модели: автор учебника + методист.
- Вход: language params + уровень + тема.

Пример (идея, адаптируй под свой пайплайн):

```
Ты — методист и автор курса грамматики. Сгенерируй ПЛАН главы.
Ограничения:
- theory_blocks: 5–7 (строго < 10)
- каждый theory_block покрывает ровно 1 главный принцип
- укажи concept_id для каждого блока
- укажи типичные ошибки русскоязычных (если уместно)
Верни ТОЛЬКО JSON по схеме:
{ chapter_outline: { ... } }
Тема: "Present Perfect vs Past Simple"
Уровень: B1
Язык интерфейса объяснений: ru
Язык примеров: en
```

**B) Промпт на генерацию одного theory‑блока**

```
Сгенерируй theory_block для concept_id="present_perfect_experience".
Нужно:
- краткое правило (1–2 абзаца)
- условия применения (bullets)
- 4–6 примеров (en + ru перевод)
- 2 типичные ошибки + правильный вариант
Верни ТОЛЬКО JSON объекта theory_block.
```

**C) Промпт на генерацию банка вопросов**

```
Сгенерируй question_bank для главы.
Ограничения:
- всего вопросов: 80 (минимум 60)
- распределение: по 12–15 вопросов на каждый theory_block_id
- типы: mcq_single, fill_blank, error_spotting, reorder (минимум по 10 каждого типа)
- каждый вопрос: prompt, options/answer, correct_answer, explanation, theory_block_id
- объяснение: 2–4 предложения, с указанием правила
Верни ТОЛЬКО JSON { questions: [...] } без лишнего текста.
```

**D) Промпт на валидацию**

```
Ты — строгий редактор. Проверь JSON главы:
- нет ли неоднозначных вопросов
- совпадает ли правильный ответ с explanation
- нет ли повторяющихся вопросов (семантически)
- покрыты ли все theory_block_id
Верни JSON { issues: [...], suggested_fixes: [...] }.
```


## 8) Организация файлов курса (чтобы не было повторов и курс собирался алгоритмически)

Рекомендованная структура (минимально‑достаточная, но масштабируемая):

- `grammar/manifest.json`
   Список разделов и глав в правильном порядке (главный индекс).
- `grammar/sections/<section_id>.json`
   Метаданные раздела + список chapter_id.
- `grammar/chapters/<chapter_id>.json`
   То, что я описал выше: блоки + локальный банк вопросов.
- `grammar/concepts/<concept_id>.json` *(опционально, но я советую)*
   Каноническая теория концепта (если хочешь убрать дубли между главами).
- `grammar/glossary/terms.json`
   Термины (tense/aspect/clause…), чтобы определение было одно на весь курс.
- `grammar/assets/...`
   Если будут картинки/аудио/карточки.

Два рабочих режима без боли:

1. **Самодостаточные главы**: всё в `chapters/*.json` (проще стартовать).
2. **Композиция из концептов**: главы содержат блоки‑ссылки на `concepts/*.json`.
    Это лучше для “вся грамматика” и будущих правок.

------

## 9) Идеи улучшений (под твой стек Go + SQLite + Vue)

### Алгоритм “тест по главе” лучше сделать чуть умнее случайности

- Стратификация по theory_block_id (как в схеме).
- Исключение “последних N вопросов” по истории пользователя.
- Если пользователь 2 раза подряд ошибся в одном theory_block → в следующем тесте повышай долю вопросов именно по нему.